/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

<<<<<<< HEAD
const fs = require("graceful-fs");
const CachedInputFileSystem = require("./CachedInputFileSystem");
const ResolverFactory = require("./ResolverFactory");

=======
const memoize = require("./util/memoize");

/** @typedef {import("./CachedInputFileSystem").BaseFileSystem} BaseFileSystem */
>>>>>>> side_work
/** @typedef {import("./PnpPlugin").PnpApiImpl} PnpApi */
/** @typedef {import("./Resolver")} Resolver */
/** @typedef {import("./Resolver").FileSystem} FileSystem */
/** @typedef {import("./Resolver").ResolveCallback} ResolveCallback */
/** @typedef {import("./Resolver").ResolveContext} ResolveContext */
/** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */
<<<<<<< HEAD
/** @typedef {import("./ResolverFactory").Plugin} Plugin */
/** @typedef {import("./ResolverFactory").UserResolveOptions} ResolveOptions */
/** @typedef {{
=======
/** @typedef {import("./Resolver").SyncFileSystem} SyncFileSystem */
/** @typedef {import("./ResolverFactory").Plugin} Plugin */
/** @typedef {import("./ResolverFactory").UserResolveOptions} ResolveOptions */

/**
 * @typedef {{
>>>>>>> side_work
 * (context: object, path: string, request: string, resolveContext: ResolveContext, callback: ResolveCallback): void;
 * (context: object, path: string, request: string, callback: ResolveCallback): void;
 * (path: string, request: string, resolveContext: ResolveContext, callback: ResolveCallback): void;
 * (path: string, request: string, callback: ResolveCallback): void;
 * }} ResolveFunctionAsync
 */
<<<<<<< HEAD
/** @typedef {{
 * (context: object, path: string, request: string): string|false;
 * (path: string, request: string): string|false;
 * }} ResolveFunction
 */

const nodeFileSystem = new CachedInputFileSystem(fs, 4000);

const nodeContext = {
	environments: ["node+es3+es5+process+native"]
};

const asyncResolver = ResolverFactory.createResolver({
	conditionNames: ["node"],
	extensions: [".js", ".json", ".node"],
	fileSystem: nodeFileSystem
});
=======

/**
 * @typedef {{
 * (context: object, path: string, request: string): string | false;
 * (path: string, request: string): string | false;
 * }} ResolveFunction
 */

const getCachedFileSystem = memoize(() => require("./CachedInputFileSystem"));

const getNodeFileSystem = memoize(() => {
	const fs = require("graceful-fs");

	const CachedInputFileSystem = getCachedFileSystem();

	return new CachedInputFileSystem(fs, 4000);
});
const getNodeContext = memoize(() => ({
	environments: ["node+es3+es5+process+native"],
}));

const getResolverFactory = memoize(() => require("./ResolverFactory"));

const getAsyncResolver = memoize(() =>
	getResolverFactory().createResolver({
		conditionNames: ["node"],
		extensions: [".js", ".json", ".node"],
		fileSystem: getNodeFileSystem(),
	}),
);
>>>>>>> side_work

/**
 * @type {ResolveFunctionAsync}
 */
const resolve =
	/**
<<<<<<< HEAD
	 * @param {object|string} context
	 * @param {string} path
	 * @param {string|ResolveContext|ResolveCallback} request
	 * @param {ResolveContext|ResolveCallback=} resolveContext
	 * @param {ResolveCallback=} callback
=======
	 * @param {object | string} context context
	 * @param {string} path path
	 * @param {string | ResolveContext | ResolveCallback} request request
	 * @param {ResolveContext | ResolveCallback=} resolveContext resolve context
	 * @param {ResolveCallback=} callback callback
>>>>>>> side_work
	 */
	(context, path, request, resolveContext, callback) => {
		if (typeof context === "string") {
			callback = /** @type {ResolveCallback} */ (resolveContext);
			resolveContext = /** @type {ResolveContext} */ (request);
			request = path;
			path = context;
<<<<<<< HEAD
			context = nodeContext;
=======
			context = getNodeContext();
>>>>>>> side_work
		}
		if (typeof callback !== "function") {
			callback = /** @type {ResolveCallback} */ (resolveContext);
		}
<<<<<<< HEAD
		asyncResolver.resolve(
=======
		getAsyncResolver().resolve(
>>>>>>> side_work
			context,
			path,
			/** @type {string} */ (request),
			/** @type {ResolveContext} */ (resolveContext),
<<<<<<< HEAD
			/** @type {ResolveCallback} */ (callback)
		);
	};

const syncResolver = ResolverFactory.createResolver({
	conditionNames: ["node"],
	extensions: [".js", ".json", ".node"],
	useSyncFileSystemCalls: true,
	fileSystem: nodeFileSystem
});
=======
			/** @type {ResolveCallback} */ (callback),
		);
	};

const getSyncResolver = memoize(() =>
	getResolverFactory().createResolver({
		conditionNames: ["node"],
		extensions: [".js", ".json", ".node"],
		useSyncFileSystemCalls: true,
		fileSystem: getNodeFileSystem(),
	}),
);
>>>>>>> side_work

/**
 * @type {ResolveFunction}
 */
const resolveSync =
	/**
<<<<<<< HEAD
	 * @param {object|string} context
	 * @param {string} path
	 * @param {string=} request
=======
	 * @param {object|string} context context
	 * @param {string} path path
	 * @param {string=} request request
	 * @returns {string | false} result
>>>>>>> side_work
	 */
	(context, path, request) => {
		if (typeof context === "string") {
			request = path;
			path = context;
<<<<<<< HEAD
			context = nodeContext;
		}
		return syncResolver.resolveSync(
			context,
			path,
			/** @type {string} */ (request)
=======
			context = getNodeContext();
		}
		return getSyncResolver().resolveSync(
			context,
			path,
			/** @type {string} */ (request),
>>>>>>> side_work
		);
	};

/** @typedef {Omit<ResolveOptions, "fileSystem"> & Partial<Pick<ResolveOptions, "fileSystem">>} ResolveOptionsOptionalFS */

/**
 * @param {ResolveOptionsOptionalFS} options Resolver options
 * @returns {ResolveFunctionAsync} Resolver function
 */
function create(options) {
<<<<<<< HEAD
	const resolver = ResolverFactory.createResolver({
		fileSystem: nodeFileSystem,
		...options
=======
	const resolver = getResolverFactory().createResolver({
		fileSystem: getNodeFileSystem(),
		...options,
>>>>>>> side_work
	});
	/**
	 * @param {object|string} context Custom context
	 * @param {string} path Base path
	 * @param {string|ResolveContext|ResolveCallback} request String to resolve
	 * @param {ResolveContext|ResolveCallback=} resolveContext Resolve context
	 * @param {ResolveCallback=} callback Result callback
	 */
<<<<<<< HEAD
	return function (context, path, request, resolveContext, callback) {
=======
	return function create(context, path, request, resolveContext, callback) {
>>>>>>> side_work
		if (typeof context === "string") {
			callback = /** @type {ResolveCallback} */ (resolveContext);
			resolveContext = /** @type {ResolveContext} */ (request);
			request = path;
			path = context;
<<<<<<< HEAD
			context = nodeContext;
=======
			context = getNodeContext();
>>>>>>> side_work
		}
		if (typeof callback !== "function") {
			callback = /** @type {ResolveCallback} */ (resolveContext);
		}
		resolver.resolve(
			context,
			path,
			/** @type {string} */ (request),
			/** @type {ResolveContext} */ (resolveContext),
<<<<<<< HEAD
			callback
=======
			callback,
>>>>>>> side_work
		);
	};
}

/**
 * @param {ResolveOptionsOptionalFS} options Resolver options
 * @returns {ResolveFunction} Resolver function
 */
function createSync(options) {
<<<<<<< HEAD
	const resolver = ResolverFactory.createResolver({
		useSyncFileSystemCalls: true,
		fileSystem: nodeFileSystem,
		...options
	});
	/**
	 * @param {object|string} context custom context
	 * @param {string} path base path
	 * @param {string=} request request to resolve
	 * @returns {string|false} Resolved path or false
	 */
	return function (context, path, request) {
		if (typeof context === "string") {
			request = path;
			path = context;
			context = nodeContext;
=======
	const resolver = getResolverFactory().createResolver({
		useSyncFileSystemCalls: true,
		fileSystem: getNodeFileSystem(),
		...options,
	});
	/**
	 * @param {object | string} context custom context
	 * @param {string} path base path
	 * @param {string=} request request to resolve
	 * @returns {string | false} Resolved path or false
	 */
	return function createSync(context, path, request) {
		if (typeof context === "string") {
			request = path;
			path = context;
			context = getNodeContext();
>>>>>>> side_work
		}
		return resolver.resolveSync(context, path, /** @type {string} */ (request));
	};
}

/**
 * @template A
 * @template B
 * @param {A} obj input a
 * @param {B} exports input b
 * @returns {A & B} merged
 */
const mergeExports = (obj, exports) => {
	const descriptors = Object.getOwnPropertyDescriptors(exports);
	Object.defineProperties(obj, descriptors);
	return /** @type {A & B} */ (Object.freeze(obj));
};

module.exports = mergeExports(resolve, {
	get sync() {
		return resolveSync;
	},
	create: mergeExports(create, {
		get sync() {
			return createSync;
<<<<<<< HEAD
		}
	}),
	ResolverFactory,
	CachedInputFileSystem,
=======
		},
	}),
	get ResolverFactory() {
		return getResolverFactory();
	},
	get CachedInputFileSystem() {
		return getCachedFileSystem();
	},
>>>>>>> side_work
	get CloneBasenamePlugin() {
		return require("./CloneBasenamePlugin");
	},
	get LogInfoPlugin() {
		return require("./LogInfoPlugin");
	},
	get forEachBail() {
		return require("./forEachBail");
<<<<<<< HEAD
	}
=======
	},
>>>>>>> side_work
});
